#version 450 core

#define BOUNCES 10
#define RAYS_PER_PIXEL 1

struct Ray {
    vec3 ro;
    vec3 rd;
};
struct Material {
    vec3 diffuseCol; // 12
    float emissiveStrength; // 4
    float roughness;
    float metallic;
};
struct HitInfo {
    bool hit;
    float dist;
    vec3 pos;
    vec3 normal;
    Material material;
};
struct Sphere {
    // base alignment   // aligned offset
    vec3 pos;           // 12               // 0
    float rad;          // 4               // 12
    Material material;  // 16               // 16
};// 32 bytes total after auto padding


layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D imgOutput;

layout (std430, binding = 1) readonly buffer ssbo {
    Sphere[] spheres;
};
uniform int numSpheres;
uniform float time;
uniform int frame;
uniform vec3 camPos;
uniform mat4 invView;
uniform mat4 invProjection;

float hash(vec3 p) {
    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123);
}

// Function to generate a random vec3 between -range and range
vec3 randomVec3(vec3 seed, float range) {
    return vec3(hash(seed + vec3(1.0, 0.0, 0.0)),
                hash(seed + vec3(0.0, 1.0, 0.0)),
                hash(seed + vec3(0.0, 0.0, 1.0))) - range;
}

HitInfo raySphereIntersect(Ray ray, Sphere sph) {
    HitInfo hi;
    hi.hit = false;
    float a = dot(ray.rd, ray.rd);
    vec3 s0_r0 = ray.ro - sph.pos;
    float b = 2.0 * dot(ray.rd, s0_r0);
    float c = dot(s0_r0, s0_r0) - (sph.rad * sph.rad);

    if (b * b - 4.0 * a * c < 0.0) {
        return hi;
    }

    // distance to sphere
    float t = (-b - sqrt((b * b) - 4.0 * a * c)) / (2.0 * a);

    if (t > 0) {
        hi.hit = true;
        hi.dist = t;
        hi.pos = ray.ro + ray.rd * t;
        hi.normal = normalize(hi.pos - sph.pos);
        hi.material = sph.material;
    }
    return hi;
}

HitInfo intersects(Ray ray) {
    HitInfo hi;
    hi.hit = false;
    hi.normal = ray.rd;

    for (int i = 0; i < numSpheres; i++) {
        HitInfo sphereHi = raySphereIntersect(ray, spheres[i]);
        if (sphereHi.hit && (!hi.hit || sphereHi.dist < hi.dist)) {
            hi = sphereHi;
        }
    }

    return hi;
}

vec3 trace(Ray ray, inout vec3 seed) {
    vec3 col = vec3(1.);
    vec3 incomingLight = vec3(0.);

    for (int i = 0; i < BOUNCES; i++) {
        HitInfo hi = intersects(ray);
        if (!hi.hit) {
            vec3 zenithColor  = vec3(0.0, 0.749, 1.0);
            vec3 horizonColor  = vec3(0.529, 0.808, 0.922);
            float perc = dot(vec3(0.0, 1.0, 0.0), hi.normal);
            vec3 skyCol = mix(horizonColor, zenithColor, clamp(perc, 0.0, 1.0));
            incomingLight += vec3(0.3) * col;
            incomingLight = clamp(incomingLight, 0.0, 1.0);
            break;
        }
        // we assumed that emissiveCol is the same as diffuseCol for the emissive sphere
        //                    emitted light                                 the lights will be tinted by all the objects
        //                                                                  that have been hit so far (explaing the * col)
        incomingLight += (hi.material.diffuseCol * hi.material.emissiveStrength) * col;
        incomingLight = clamp(incomingLight, 0.0, 1.0);
        col *= hi.material.diffuseCol;


        Ray newRay;
        newRay.ro = hi.pos + hi.normal * 0.001;
        vec3 diffuseDir = normalize(hi.normal + randomVec3(seed, 0.5));
        vec3 specularReflectionDir = reflect(ray.rd, hi.normal);

        newRay.rd = mix(specularReflectionDir, diffuseDir, hi.material.roughness);




        ray = newRay;
    }

    return incomingLight;
}

mat3 Pitch(float a) {
    float Sin = sin(a);
    float Cos = cos(a);

    return mat3(1, 0, 0,
                0, Cos, -Sin,
                0, Sin, Cos);
}

mat3 Yaw(float a) {
    float Sin = sin(a);
    float Cos = cos(a);

    return mat3(Cos, 0, Sin,
                0, 1, 0,
                -Sin, 0, Cos);
}



void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    // Here gl_NumWorkGroups is basically resolution
    vec2 uv;
    uv.x = (float(texelCoord.x) - .5 * gl_NumWorkGroups.x);
    uv.y = (float(texelCoord.y) - .5 * gl_NumWorkGroups.y);
    uv /= gl_NumWorkGroups.xy;

    vec3 seed = vec3(uv, time);

    Ray cam;
    cam.ro = camPos;
    vec4 target = invProjection * vec4(uv.x, uv.y, 1.0, 1.0);
    vec3 normalizedTarget = normalize(vec3(target) / target.w);
    cam.rd = vec3(invView * vec4(normalizedTarget, 0.0));

    vec3 col = trace(cam, seed);

    float weight = 1.0 / (frame + 1);
    vec3 colPrev = imageLoad(imgOutput, texelCoord).rgb;
    vec3 finalCol = clamp(colPrev * (1 - weight) + col * weight, 0.0, 1.0);

    imageStore(imgOutput, texelCoord, vec4(finalCol, 1.0));
}
#version 450 core

//#define BOUNCES 10
//#define RAYS_PER_PIXEL 1
#define JITTER 0.000
#define PI 3.14159265359f

struct Material {
    vec3 diffuseCol; // 12
    float emissiveStrength; // 4
    float roughness; // 4
    float specularPerc; // 4
};

struct Ray {
    vec3 ro;
    vec3 rd;
};

struct HitInfo {
    bool hit;
    float dist;
    vec3 pos;
    vec3 normal;
    Material material;
};

struct Sphere {
                        // base alignment   // aligned offset
    vec3 pos;           // 12               // 0
    float rad;          // 4               // 12
    Material material;  // 16               // 16
};                      // 32 bytes

struct Triangle {
    vec3 v0;
    vec3 v1;
    vec3 v2;
    Material material;
};                      // 12*3 + 16 = 52 bytes total


layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D imgOutput;

layout (std430, binding = 1) readonly buffer ssbo {
    Sphere[] spheres;
};

// Render uniforms
uniform int frame;
uniform int BOUNCES;
uniform int RAYS_PER_PIXEL;
// Cam uniforms
uniform vec3 camPos;
uniform mat4 invView;
uniform mat4 invProjection;
// Geometries uniform
uniform int numSpheres;


// ========= TEST BOX =========
Triangle[12] buildTestBox() {
    Material grayMat = Material(vec3(0.7, 0.7, 0.7), 0.0, 0.7, 0.5);
    Material redMat = Material(vec3(0.7, 0.1, 0.1), 0.0, 0.7, 0.5);
    Material greenMat = Material(vec3(0.1, 0.7, 0.1), 0.0, 0.7, 0.5);
    Material lightMat = Material(vec3(1.0, 1.0, 1.0), 5.0, 0.7, 0.5);

    Triangle triangles[12];
    // Floor
    triangles[0] = Triangle(vec3(-1.0, -1.0, -1.0), vec3(1.0, -1.0, -1.0), vec3(1.0, -1.0, 1.0), grayMat);
    triangles[1] = Triangle(vec3(-1.0, -1.0, -1.0), vec3(1.0, -1.0, 1.0), vec3(-1.0, -1.0, 1.0), grayMat);

    // Ceiling
    triangles[2] = Triangle(vec3(-1.0, 1.0, -1.0), vec3(1.0, 1.0, -1.0), vec3(1.0, 1.0, 1.0), grayMat);
    triangles[3] = Triangle(vec3(-1.0, 1.0, -1.0), vec3(1.0, 1.0, 1.0), vec3(-1.0, 1.0, 1.0), grayMat);

    // Back wall
    triangles[4] = Triangle(vec3(-1.0, -1.0, 1.0), vec3(1.0, -1.0, 1.0), vec3(1.0, 1.0, 1.0), grayMat);
    triangles[5] = Triangle(vec3(-1.0, -1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(-1.0, 1.0, 1.0), grayMat);

    // Left wall (red)
    triangles[6] = Triangle(vec3(-1.0, -1.0, -1.0), vec3(-1.0, -1.0, 1.0), vec3(-1.0, 1.0, 1.0), redMat);
    triangles[7] = Triangle(vec3(-1.0, -1.0, -1.0), vec3(-1.0, 1.0, 1.0), vec3(-1.0, 1.0, -1.0), redMat);

    // Right wall (green)
    triangles[8] = Triangle(vec3(1.0, -1.0, -1.0), vec3(1.0, -1.0, 1.0), vec3(1.0, 1.0, 1.0), greenMat);
    triangles[9] = Triangle(vec3(1.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, -1.0), greenMat);

    triangles[10] = Triangle(vec3(-0.5, 0.99, -0.5), vec3(0.5, 0.99, -0.5), vec3(0.5, 0.99, 0.5), lightMat);
    triangles[11] = Triangle(vec3(-0.5, 0.99, -0.5), vec3(0.5, 0.99, 0.5), vec3(-0.5, 0.99, 0.5), lightMat);

    return triangles;
}
// ====================================


// ========= RANDOM FUNCTIONS =========
uint wang_hash(inout uint seed) {
    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);
    return seed;
}

float randomFloat01(inout uint state) {
    return float(wang_hash(state)) / 4294967296.0;
}

vec3 randomUnitVector(inout uint state) {
    float z = randomFloat01(state) * 2.0f - 1.0f;
    float a = randomFloat01(state) * 2.0 * PI;
    float r = sqrt(1.0f - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return vec3(x, y, z);
}
// ====================================


// ========= RAY SURFACE =========
HitInfo raySphereIntersect(Ray ray, Sphere sph) {
    HitInfo hi;
    hi.hit = false;
    float a = dot(ray.rd, ray.rd);
    vec3 s0_r0 = ray.ro - sph.pos;
    float b = 2.0 * dot(ray.rd, s0_r0);
    float c = dot(s0_r0, s0_r0) - (sph.rad * sph.rad);

    if (b * b - 4.0 * a * c < 0.0) {
        return hi;
    }
    // distance to sphere
    float t = (-b - sqrt((b * b) - 4.0 * a * c)) / (2.0 * a);

    if (t > 0) {
        hi.hit = true;
        hi.dist = t;
        hi.pos = ray.ro + ray.rd * t;
        hi.normal = normalize(hi.pos - sph.pos);
        hi.material = sph.material;
    }
    return hi;
}

HitInfo rayTriangleIntersect(Ray ray, Triangle tri) {
    HitInfo hi;
    hi.hit = false;
    hi.dist = -1.0;

    vec3 v1v0 = tri.v1 - tri.v0;
    vec3 v2v0 = tri.v2 - tri.v0;
    vec3 rov0 = ray.ro - tri.v0;
    vec3 n = cross(v1v0, v2v0);

    vec3 q = cross(rov0, ray.rd);
    float d = 1.0 / dot(ray.rd, n);
    float u = d * dot(-q, v2v0);
    float v = d * dot(q, v1v0);
    float t = d * dot(-n, rov0);

    if (u >= 0.0 && v >= 0.0 && (u + v) <= 1.0 && t > 0.0) {
        hi.hit = true;
        hi.dist = t;
        hi.pos = ray.ro + ray.rd * t;
        if (dot(n, ray.rd) > 0.0) {
            n = -n;  // Flip the normal if it's not facing the ray origin
        }
        hi.normal = normalize(n);
        hi.material = tri.material;
    }

    return hi;
}
// ====================================


HitInfo intersects(Ray ray) {
    HitInfo hi;
    hi.hit = false;

    Triangle box[12] = buildTestBox();

    for (int i = 0; i < numSpheres; i++) {
        HitInfo sphereHi = raySphereIntersect(ray, spheres[i]);
        if (sphereHi.hit && (!hi.hit || sphereHi.dist < hi.dist)) {
            hi = sphereHi;
        }
    }
    for (int i = 0; i < 12; i++) {
        HitInfo triangleHi = rayTriangleIntersect(ray, box[i]);
        if (triangleHi.hit && (!hi.hit || triangleHi.dist < hi.dist)) {
            hi = triangleHi;
        }
    }

    return hi;
}

vec3 trace(Ray ray, inout uint seed) {
    vec3 rayCol = vec3(1.);
    vec3 pixelColor = vec3(0.);

    for (int i = 0; i < BOUNCES; i++) {
        HitInfo hi = intersects(ray);
        if (!hi.hit) {
            break;
        }
        // we assumed that emissiveCol is the same as diffuseCol for the emissive objects (1 less mat component to share)
        //                    emitted light                                 the incomming light will be tinted by all the objects
        //                                                                  that have been hit so far (explaing the * col)
        pixelColor += (hi.material.diffuseCol * hi.material.emissiveStrength) * rayCol;
        rayCol *= hi.material.diffuseCol;

        Ray newRay;
        newRay.ro = hi.pos + hi.normal * 0.001;

        // roughness component
        vec3 diffuseDir = normalize(hi.normal + randomUnitVector(seed));
        vec3 specularReflectionDir = reflect(ray.rd, hi.normal);
        specularReflectionDir = normalize(mix(specularReflectionDir, diffuseDir, hi.material.roughness));

        // ~metallic component
        float shouldSpecular = (randomFloat01(seed) < hi.material.specularPerc) ? 1.0f : 0.0f;
        newRay.rd = normalize(mix(diffuseDir, specularReflectionDir, shouldSpecular));

        ray = newRay;
    }

    return pixelColor;
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    // Here gl_NumWorkGroups is basically resolution
    vec2 uv;
    uv.x = (float(texelCoord.x) - .5 * gl_NumWorkGroups.x);
    uv.y = (float(texelCoord.y) - .5 * gl_NumWorkGroups.y);
    uv /= gl_NumWorkGroups.xy;

    uint seed = uint(uint(texelCoord.x) * uint(1973) + uint(texelCoord.y) * uint(9277) + uint(frame) * uint(26699)) | uint(1);

    Ray cam;
    cam.ro = camPos;
    vec4 target = invProjection * vec4(uv.x, uv.y, 1.0, 1.0);
    vec3 normalizedTarget = normalize(vec3(target) / target.w);
    cam.rd = vec3(invView * vec4(normalizedTarget, 0.0));

    vec3 col;
    for (int i = 0; i < RAYS_PER_PIXEL; i++) {
        Ray randomCam;
        randomCam.ro = cam.ro;
        randomCam.rd = normalize(cam.rd + JITTER * randomUnitVector(seed));
        col += trace(randomCam, seed) / float(RAYS_PER_PIXEL);
    }

    vec3 colPrev = imageLoad(imgOutput, texelCoord).rgb;
    col = mix(colPrev, col, 1.0 / (float(frame) + 1));

    imageStore(imgOutput, texelCoord, vec4(col, 1.0));
}